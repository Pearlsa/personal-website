<!doctype html><html><head><title>SemVer comparisons with OPA
- charlieegan3</title><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta name=description content="Update: I&rsquo;ve written a follow up post here explaining how I later added this functionality to Rego itself.
I recently found myself faced with the task of writing OPA policies that involved comparing Semantic Versions."><meta name=twitter:card content="summary"><meta name=twitter:site content="@charlieegan3"><meta name=twitter:creator content="@charlieegan3"><meta property="og:url" content="https://charlieegan3.com/posts/2020-05-08-semver-comparisons-with-opa/"><meta property="og:title" content="SemVer comparisons with OPA"><meta property="og:description" content="Update: I&rsquo;ve written a follow up post here explaining how I later added this functionality to Rego itself.
I recently found myself faced with the task of writing OPA policies that involved comparing Semantic Versions."><meta property="og:type" content="article"><meta name=author content="Charlie Egan"><meta property="article:author" content="https://twitter.com/charlieegan3"><meta property="article:published_time" content="2020-05-08T11:29:00"><meta property="og:image" content="https://charlieegan3.com/posts/2020-05-08-semver-comparisons-with-opa/versions.png"><link rel=stylesheet type=text/css href=/css/bundle.min.c144bb18591ee3d9ef85fb73056afa69f6c8fa31188080cb491de5b71bbf36e1.css><script type=text/javascript src=/js/bundle.min.76c0ad1f61fe83a23628b79ecc5aa835224071f00c5f2a4fbbdf26765027d8e7.js integrity="sha256-dsCtH2H+g6I2KLeezFqoNSJAcfAMXypPu98mdlAn2Oc="></script></head><body class="bg-darker-gray light-silver"><section class="mw7 center pa3 ph5-ns pb5"><nav class=sidebar-nav><a href=/ title=homepage>home</a>
<a href=/about/ title="read all about it">about</a>
<a class="bb bw1 b--silver" href=/posts/ title="view my blog posts">posts</a>
<a href=/projects/ title="view my projects">projects</a>
<a href=/profiles/ title="find me elsewhere">profiles</a>
<a href=/search><img class="fr grow" style=width:20px;filer:invert(.75);-webkit-filter:invert(.75) src=/search.svg></a></nav><h1 class="f3-ns f4">SemVer comparisons with OPA</h1><div class="f5-ns f6 gray bb bw1 pb2 b--dark-gray">Posted May 8 2020</div><div class=post-content><p><strong>Update:</strong> I&rsquo;ve written a follow up post <a href=/posts/2020-08-31-rego-semver-contribution/>here</a> explaining how I later added this functionality to Rego itself.</p><p><img src=versions.png alt=versions.png></p><p>I recently found myself faced with the task of writing <a href=https://www.openpolicyagent.org/>OPA</a> policies that involved comparing <a href=https://semver.org/>Semantic Versions</a>. It seemed like an interesting challenge, and something more useful than <a href=https://www.notion.so/posts/2019-12-05-rego-fun/>validating Christmas trees</a>&mldr;</p><p>This was the end goal, a function that was able to compare two versions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>is_greater_or_equal</span>(<span style=color:#e6db74>&#34;1.0.0&#34;</span>, <span style=color:#e6db74>&#34;0.1.0&#34;</span>)
<span style=color:#75715e>// =&gt; true
</span><span style=color:#75715e></span><span style=color:#a6e22e>is_greater_or_equal</span>(<span style=color:#e6db74>&#34;1.0.0&#34;</span>, <span style=color:#e6db74>&#34;2.0.0&#34;</span>)
<span style=color:#75715e>// =&gt; false
</span><span style=color:#75715e></span><span style=color:#a6e22e>is_greater_or_equal</span>(<span style=color:#e6db74>&#34;1.0.0&#34;</span>, <span style=color:#e6db74>&#34;1&#34;</span>)
<span style=color:#75715e>// =&gt; true
</span></code></pre></div><p>While some of the functions are refined from their original implementations, the
process went something like this.</p><h2 id=how-can-we-parse-versions-and-represent-them>How can we parse versions and represent them?</h2><p>First, I decided on an internal representation for a Semantic Version, I settled
on the following object - for better or worse.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>{
  <span style=color:#e6db74>&#34;major&#34;</span>: <span style=color:#66d9ef>int</span>,
  <span style=color:#e6db74>&#34;minor&#34;</span>: <span style=color:#66d9ef>int</span>,
  <span style=color:#e6db74>&#34;patch&#34;</span>: <span style=color:#66d9ef>int</span>,
}
</code></pre></div><p>Next, I needed a means of parsing the version strings and getting back versions
in my representation. So I needed the following to work:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#e6db74>&#34;1.0.0&#34;</span>)
<span style=color:#75715e>// =&gt; { &#34;major&#34;: 1, &#34;minor&#34;: 0, &#34;patch&#34;: 0 }
</span><span style=color:#75715e></span><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#e6db74>&#34;2.3.4&#34;</span>)
<span style=color:#75715e>// =&gt; { &#34;major&#34;: 2, &#34;minor&#34;: 3, &#34;patch&#34;: 4 }
</span><span style=color:#75715e></span>
<span style=color:#75715e>// but also...
</span><span style=color:#75715e></span><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#e6db74>&#34;1.0&#34;</span>)
<span style=color:#75715e>// =&gt; { &#34;major&#34;: 1, &#34;minor&#34;: 0, &#34;patch&#34;: 0 }
</span><span style=color:#75715e></span><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#e6db74>&#34;1&#34;</span>)
<span style=color:#75715e>// =&gt; { &#34;major&#34;: 1, &#34;minor&#34;: 0, &#34;patch&#34;: 0 }
</span><span style=color:#75715e></span>
<span style=color:#75715e>// and also...
</span><span style=color:#75715e></span><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#e6db74>&#34;v1.0.0&#34;</span>)
<span style=color:#75715e>// =&gt; { &#34;major&#34;: 1, &#34;minor&#34;: 0, &#34;patch&#34;: 0 }
</span></code></pre></div><p>To implement <code>parse_version_string</code>, it seemed to make sense to start by
splitting on &lsquo;.&rsquo; - then all I needed was a means of creating a new version from
the split data.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>parse_version_string</span>(<span style=color:#a6e22e>version_string</span>) = <span style=color:#a6e22e>version</span> {
	<span style=color:#a6e22e>components</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>split</span>(<span style=color:#a6e22e>version_string</span>, <span style=color:#e6db74>&#34;.&#34;</span>)
	<span style=color:#a6e22e>version</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>new_version_from_components</span>(<span style=color:#a6e22e>components</span>, <span style=color:#a6e22e>count</span>(<span style=color:#a6e22e>components</span>))
}
</code></pre></div><p>Using multiple function heads (or whatever these are called in Rego) seemed like
an ok way to handle the different lengths. I called <em>major</em>, <em>minor</em> and <em>patch</em>
‘components’ <em>sigh</em>, nice and generic&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>new_version_from_components</span>(<span style=color:#a6e22e>components</span>, <span style=color:#ae81ff>1</span>) = <span style=color:#a6e22e>version</span> {
	<span style=color:#a6e22e>version</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>new_version</span>(<span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
}
<span style=color:#a6e22e>new_version_from_components</span>(<span style=color:#a6e22e>components</span>, <span style=color:#ae81ff>2</span>) = <span style=color:#a6e22e>version</span> {
	<span style=color:#a6e22e>version</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>new_version</span>(<span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>0</span>)
}
<span style=color:#a6e22e>new_version_from_components</span>(<span style=color:#a6e22e>components</span>, <span style=color:#ae81ff>3</span>) = <span style=color:#a6e22e>version</span> {
	<span style=color:#a6e22e>version</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>new_version</span>(<span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>components</span>[<span style=color:#ae81ff>2</span>])
}
<span style=color:#a6e22e>new_version</span>(<span style=color:#a6e22e>major</span>, <span style=color:#a6e22e>minor</span>, <span style=color:#a6e22e>patch</span>) = <span style=color:#a6e22e>version</span> {
	<span style=color:#a6e22e>version</span> <span style=color:#f92672>:=</span> {
			<span style=color:#e6db74>&#34;major&#34;</span>: <span style=color:#a6e22e>to_number</span>(<span style=color:#a6e22e>trim_prefix</span>(<span style=color:#a6e22e>sprintf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>, [<span style=color:#a6e22e>major</span>]), <span style=color:#e6db74>&#34;v&#34;</span>)),
			<span style=color:#e6db74>&#34;minor&#34;</span>: <span style=color:#a6e22e>to_number</span>(<span style=color:#a6e22e>minor</span>),
			<span style=color:#e6db74>&#34;patch&#34;</span>: <span style=color:#a6e22e>to_number</span>(<span style=color:#a6e22e>patch</span>)
		}
}
</code></pre></div><p>Note that I also wanted <code>new_version</code> to work with strings or numbers (this made my tests easier to write and handling the &lsquo;v&rsquo; prefix possible).</p><p>So now I have a means of creating versions in my internal representation.</p><h2 id=what-does-greater-mean-and-how-do-we-define-it>What does &lsquo;greater&rsquo; mean and how do we define it?</h2><p>What does ‘greater’ mean in SemVer? I didn’t read the spec, so this might be
missing something, but my definition was any of the following:</p><ul><li>major version is greater</li><li>major is equal, and minor version is greater</li><li>major is equal, minor is equal, patch is greater</li></ul><p>Now I needed to find a means of writing this in Rego. Fundamentally, I need to
make comparisons between the parts of the version. I created two functions like
this which operate on two versions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>is_key_greater</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) = <span style=color:#a6e22e>result</span> {
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>key</span>] &gt; <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>key</span>]
}
<span style=color:#a6e22e>is_key_equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) = <span style=color:#a6e22e>result</span> {
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>key</span>]
}
</code></pre></div><p>These will return the integer comparison of the components at the given ‘key’
(major, minor, or patch).</p><p>With these building blocks I can implement my definition for ‘is greater’:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>is_greater</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) = <span style=color:#a6e22e>result</span> {
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> {
		{ <span style=color:#a6e22e>is_key_greater</span>(<span style=color:#e6db74>&#34;major&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) },
		{ <span style=color:#a6e22e>is_key_equal</span>(<span style=color:#e6db74>&#34;major&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>is_key_greater</span>(<span style=color:#e6db74>&#34;minor&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) },
		{ <span style=color:#a6e22e>is_key_equal</span>(<span style=color:#e6db74>&#34;major&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>is_key_equal</span>(<span style=color:#e6db74>&#34;minor&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>is_key_greater</span>(<span style=color:#e6db74>&#34;patch&#34;</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) },
	} <span style=color:#f92672>&amp;</span> { { <span style=color:#66d9ef>true</span> } } <span style=color:#f92672>==</span> { { <span style=color:#66d9ef>true</span> } }
}
</code></pre></div><p>This reads as: “bind the result to true if the set of conditions contains one
that is true; where a condition is true if all the sub conditions are also
true”. Sub conditions in this case being the comparisons between the version
components.</p><p>In order to achieve world domination with <code>is_greater_or_equal</code> we also need to
have a definition for version equality - this one is more straight forward:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>is_equal</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) = <span style=color:#a6e22e>result</span> {
	<span style=color:#a6e22e>keys</span> <span style=color:#f92672>:=</span> [<span style=color:#e6db74>&#34;major&#34;</span>, <span style=color:#e6db74>&#34;minor&#34;</span>, <span style=color:#e6db74>&#34;patch&#34;</span>]
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> { <span style=color:#a6e22e>r</span> | <span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>keys</span>[<span style=color:#a6e22e>_</span>]; <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>is_key_equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) } <span style=color:#f92672>==</span> { <span style=color:#66d9ef>true</span> }
}
</code></pre></div><p>I read this as, “for all version components (with keys master, minor, patch),
check the components in both versions are strictly equal”.</p><p>With these two, the implementation of <code>is_greater_or_equal</code> is trivial:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>is_greater_or_equal</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) = <span style=color:#a6e22e>result</span> {
	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> {
		<span style=color:#a6e22e>is_greater</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>),
		<span style=color:#a6e22e>is_equal</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>),
	} <span style=color:#f92672>&amp;</span> { <span style=color:#66d9ef>true</span> } <span style=color:#f92672>==</span> { <span style=color:#66d9ef>true</span> }
}
</code></pre></div><p>I read this as: “any element in the set { is_greater(a, b), is_equal(a, b) } is
true”. We test this using set intersection with <code>{ true }</code>.</p><h2 id=this-is-a-mess-you-should-go-back-to-school>This is a mess, you should go back to school!</h2><p>I’ve been writing Rego policies for a while now, I find them fun - a little like a puzzle or something. However, I have no background in logic programming and sometimes wonder if there is a better way to do things. I still regularly find myself mapping from imperative thinking to my declarative policies.</p><p>You can review all the code in <a href=https://gist.github.com/charlieegan3/76dbec05c65164ac98dfec74b1381c5a>this gist</a>. Feel free to comment there if you have questions or suggestions. I’m also on <a href=https://twitter.com/charlieegan3>Twitter</a>.</p></div></section></body></html>